(function (require) {
require = (function (cache, modules) {
return function (r) {
if (!modules[r]) throw new Error(r + ' is not a module');
return cache[r] ? cache[r].exports : ((cache[r] = {
exports: {}
}, cache[r].exports = modules[r](require, cache[r], cache[r].exports)));
};
})({}, {
1: function (require, module, exports) {
(function(){

  function LazyEvents(target = {}){

    const events = {};

    Object.defineProperty(target, 'on', {
      get: ()=>{
        return on;
      }
    })
    Object.defineProperty(target, 'one', {
      get: ()=>{
        return one;
      }
    })
    Object.defineProperty(target, 'off', {
      get: ()=>{
        return off;
      }
    })
    Object.defineProperty(target, 'emit', {
      get: ()=>{
        return emit;
      }
    })

    /**
     * Events On.
     * You can listen to '*' and listen to all events
     * @param  {String}   label   Event to listen to
     * @param  {Function} cb      Required. This is the function that will be
     *                            called when the event is triggered.
     * @param  {Boolean}   lazy   When true, it will run even if the emit happens
     *                            after the event is registered. When false, it
     *                            will not trigger until an emit happens after it
     *                            has been registered.
     * @return {undefined}
     */
    function on(label, cb, lazy = true){
      if(typeof cb !== 'function') throw new Error('Callback on events must be a function.')
      if(typeof events[label] == 'undefined'){
        events[label] = []
        events[label].__ran__ = false;
        events[label].__args__ = [];
      }
      events[label].push(cb)
      if(events[label].__ran__ && lazy){
        cb.apply(target, events[label].__args__)
      }

      return target;
    }

    /**
     * Events One.
     * Same as On, but will immediately remove itself once it has resolved once.
     */
    function one(label, cb, lazy = true){
      let _cb = function(){ // do not use double arrow here, it messes up arguments
        let args = Array.from(arguments);
        cb.apply(target, args)
        off(label, _cb);
      }
      on(label, _cb, lazy)
      return target;
    }


    /**
     * Events Off.
     * @param  {String}   label Event to remove
     * @param  {[Function]} cb    Optional. If not provided all events of label
     *                            will be removed. If provided, only events with
     *                            the same callback will be removed.
     * @return {undefined}
     */
    function off(label, cb){
      if(typeof events[label] === 'undefined') return;

      if(typeof cb === 'undefined'){
        delete events[label];
        return;
      }

      for(let i=0; i<events[label].length; i++){
        if(events[label][i] === cb){
          events[label].splice(i, 1);
          i--;
        }
      }
      return target;
    }

    /**
     * Events Emit.
     * @param  {String}   label   Event to emit
     * @param  {Arguments} arguments  All arguments after label will be sent to
     *                                listener.
     * @return {undefined}
     */
    function emit(label){

      if(typeof events[label] == 'undefined'){
        events[label] = []
      }

      // Store incoming values for future listeners
      let args = Array.from(arguments);
      args.shift();
      events[label].__ran__ = true;
      events[label].__args__ = args;

      events[label].forEach((event)=>{
        event.apply(target, events[label].__args__)
      })

      if(typeof events['*'] !== 'undefined'){
        events['*'].forEach((event)=>{
          let args = [].concat(label, events[label].__args__);
          event.apply(target, args);
        })
      }
      return target;
    }

    return target;
  }

  if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
    module.exports = LazyEvents;
  }else if(typeof define === 'function' && define.amd) {
    define([], function() {
      return LazyEvents;
    });
  }else{
    window.LazyEvents = LazyEvents;
  }
})()
;
return module.exports;
},
0: function (require, module, exports) {
(function(){

  const lazy = require(1)({});

  /**
   * TODO: Save and restore
   * after some consideration, I do not allow multiple stores, as I feel
   * the store should be global.
   */

  let debug = false;
  function log(){
    if(debug) console.log.apply(console, arguments);
  }

  function traversable(value){
    if(Array.isArray(value) || (typeof value === 'object' && value !== null)){
      return true;
    }
    return false;
  }

  class ProxyArray extends Array{}
  class ProxyObject extends Object{}

  function fillDefaults(value, proxy){
    if(!traversable(value)){
      if(proxy !== null && typeof proxy === 'object'){
        if(!Object.keys(proxy).length) proxy.__parent__[proxy.__key__] = value;
      }else if(Array.isArray(proxy)){
        // This is not sophisticated at all! does not do deep checking on array.
        if(!proxy.length) proxy.__parent__[proxy.__key__] = value;
      }
      // it's already set manually
    }else{
      // we know the proxy is traversable otherwise we could not call .defaults
      for(i in value){
       fillDefaults(value[i], proxy[i])
      }
    }
  }

  /**
   * The parent and key are necessary to modify the chain and not break
   * references
   * @param  {Object | Array} __target__ What we are making into a proxy
   * @param {Object} parent The parent of the __target__
   * @param {[type]} key   The key or property on the parent that defines the __target__
   * @return {Proxy Object} Use your object like normal.
   */
  function makeProxy(__target__, parent, key){
    let proxy = new Proxy(__target__, {
      get: (target, name)=>{
        log('getting', name)

        // Request to turn object to JSON from JSON.stringify
        if(name === 'toJSON'){
          log('making json', name)
          return JSON.stringify(target[name]);
        }

        if(name in target){
          log('returning', name)
          return target[name]
        }

        if(typeof name === 'symbol'){
          log('ignoring', name)
          return
        }

        if(name === 'inspect'){
          log('ignoring', name);
          return;
        }

        if(!isNaN(Number(name))){
          log(name, 'is a number')
          // We are trying to access an array, but it's not an array, convert it
          let i = Number(name);
          if(!Array.isArray(target)){ // TODO: what does this do for strings?
            log('converting parent to array', name)
            target.__parent__[target.__key__] = makeProxy(new ProxyArray(), target.__parent__, target.__key__)
            target.__parent__[target.__key__][i] = makeProxy(new ProxyObject(), target.__parent__[target.__key__], i)
            return target.__parent__[target.__key__][i]
          }else{
            log('parent is already an array', name)
            target[i] = makeProxy(new ProxyArray(), target, i);
            return target[i];
          }
        }else{
          log(name, 'is not a number')
          // We are trying to access an object, but it's not, convert it
          if(Array.isArray(target)){
            log('converting parent to object', name)
            target.__parent__[target.__key__] = makeProxy(new ProxyObject(), target.__parent__, target.__key__)
            target.__parent__[target.__key__][name] = makeProxy(new ProxyObject(), target.__parent__[target.__key__], name)
            return target.__parent__[target.__key__][name]
          }else{
            log('parent is already an object', name)
            target[name] = makeProxy(new ProxyObject(), target, name);
            return target[name]
          }
        }


        /**
         * Some of the values I know of that we are ignoring
         * {} Symbol(util.inspect.custom) true
         * {} 'valueOf' true
         * {} Symbol(Symbol.toStringTag) true
         * {} Symbol(Symbol.toStringTag) true
         */
      },

      set: (target, name, value, receiver)=>{
        log('setting value', name, target.__label__)
        if(traversable(value)){
          log('value is an array. is it already a proxy?', name)
          // if it already has a __proxy__, then it is being set from the getter.
          // we don't need to make it a proxy again.
          if(!value.__proxy__){
            log('it is not a proxy, we need to make it one', name)
            target[name] = makeProxy(value, target, name);
            lazy.emit(target.__label__ + '.' + name.toString(), target[name])
            return true;
          }
        }
        // primitive or already a proxy
        target[name] = value;
        lazy.emit(target.__label__ + '.' + name.toString(), target[name])
        return true;
      }
    });

    Object.defineProperty(proxy, '__parent__', {
      get: ()=>{
        return parent;
      }
    })
    Object.defineProperty(proxy, '__key__', {
      get: ()=>{
        return key;
      }
    })
    Object.defineProperty(proxy, '__proxy__', {
      get: ()=>{
        return true;
      }
    })
    Object.defineProperty(proxy, '__label__', {
      get: ()=>{
        return (parent.__label__ ? (parent.__label__ + '.') : '') + key.toString();
      }
    })
    Object.defineProperty(proxy, 'defaults', {
      get: ()=>{
        log('get proxy', proxy, proxy.__label__)
        return proxy;
      },
      set: (value)=>{
        log('set proxy', value, proxy, proxy.__label__)
        fillDefaults(value, proxy, __target__)
      }
    })

    // They are wanting to make a proxy of full object or array
    // All the children need to be proxied as well.
    if(traversable(proxy)){
      for(i in proxy){
        log('checking value', i)
        if(traversable(proxy[i])){
          log('converting to proxy', i)
          proxy[i] = makeProxy(proxy[i], proxy, i);
        }else{
          // this is necessary so the 'setter' will trigger
          proxy[i] = proxy[i];
        }
      }
    }

    return proxy;
  }

  // This is so we have something to actually proxy.
  const root = {
    store: {}
  };
  let proxy;

  function set(value){
    if(!traversable(value)){
      throw new Error('Store must be an array or an object.')
    }

    proxy = makeProxy(value, root, 'store')

    // add event handler back on.
    Object.defineProperty(proxy, 'on', {
      enumerable: false,
      configurable: false,
      writable: false,
      value: lazy.on
    });
    Object.defineProperty(proxy, 'one', {
      enumerable: false,
      configurable: false,
      writable: false,
      value: lazy.one
    });
    Object.defineProperty(proxy, 'off', {
      enumerable: false,
      configurable: false,
      writable: false,
      value: lazy.off
    });

    // provide a means to set the proxy
    Object.defineProperty(proxy, 'set', {
      enumerable: false,
      configurable: false,
      writable: false,
      value: set
    })

    return proxy
  }

  // build proxy
  set({})


  if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
    module.exports = proxy;
  }else if(typeof define === 'function' && define.amd) {
    define([], function() {
      return proxy;
    });
  }
  if(typeof window === 'object'){
    Object.defineProperty(window, 'ProxyStore', {
      set: set,
      get: ()=>{
        return proxy;
      }
    })
  }
})()
;
return module.exports;
}
});
return require(0);
}).call(this, null);
