(function (require) {
require = (function (cache, modules) {
return function (r) {
if (!modules[r]) throw new Error(r + ' is not a module');
return cache[r] ? cache[r].exports : ((cache[r] = {
exports: {}
}, cache[r].exports = modules[r](require, cache[r], cache[r].exports)));
};
})({}, {
0: function (require, module, exports) {
(function(){

  const lazy = require(1)({});

  /**
   * TODO: Save and restore
   * after some consideration, I do not allow multiple stores, as I feel
   * the store should be global.
   */

  let debug = false;
  function log(){
    if(debug) log.apply(console, arguments);
  }

  function traversable(value){
    return (Array.isArray(value) || (typeof value === 'object' && value !== null));
  }

  class ProxyArray extends Array{}
  class ProxyObject extends Object{}

  function fillDefaults(value, proxy){
    if(!traversable(value)){
      if(proxy !== null && typeof proxy === 'object'){
        if(!Object.keys(proxy).length) proxy.__parent__[proxy.__key__] = value;
      }else if(Array.isArray(proxy)){
        // This is not sophisticated at all! does not do deep checking on array.
        if(!proxy.length) proxy.__parent__[proxy.__key__] = value;
      }
      // it's already set manually
    }else{
      // we know the proxy is traversable otherwise we could not call .defaults
      for(let i in value){
       fillDefaults(value[i], proxy[i])
      }
    }
  }

  /**
   * The parent and key are necessary to modify the chain and not break
   * references
   * @param  {Object | Array} __target__ What we are making into a proxy
   * @param {Object} parent The parent of the __target__
   * @param {[type]} key   The key or property on the parent that defines the __target__
   * @return {Proxy Object} Use your object like normal.
   */
  function makeProxy(__target__, parent, key){
    log('creating proxy', __target__, parent, key)

    let proxy = (Array.isArray(__target__) ? [] : {});
    Object.defineProperty(proxy, '__parent__', {
      enumerable: false,
      get: ()=>{
        return parent;
      }
    })
    Object.defineProperty(proxy, '__key__', {
      enumerable: false,
      get: ()=>{
        return key;
      }
    })
    Object.defineProperty(proxy, '__proxy__', {
      enumerable: false,
      get: ()=>{
        return true;
      }
    })
    Object.defineProperty(proxy, '__label__', {
      enumerable: false,
      get: ()=>{
        return (parent.__label__ ? (parent.__label__ + '.') : '') + key.toString();
      }
    })
    Object.defineProperty(proxy, 'default', {
      enumerable: false,
      get: ()=>{
        return (value)=>{
          log('set proxy defaults', value, parent[key], parent[key].__label__)
          fillDefaults(value, parent[key], __target__)
        }
        //log('getting defaults')
        //log('get proxy', parent[key], parent[key].__label__)
        //return parent[key];
      }
    })

    parent[key] = new Proxy( proxy , {
      get: (target, name)=>{
        log('getting', name)

        // Request to turn object to JSON from JSON.stringify
        if(name === 'toJSON'){
          log('making json', name)
          return JSON.stringify(target[name]);
        }

        if(name in target){
          log('returning', name)
          return target[name]
        }

        // Return length of object keys or array
        if(name === 'length'){
          return typeof target === 'object' ? Object.keys(target).length : target.length;
        }

        if(typeof name === 'symbol'){
          log('ignoring', name)
          return
        }

        if(name === 'inspect'){
          log('ignoring', name);
          return;
        }

        log('checking', name, target, target.__proxy__)
        if(!isNaN(Number(name))){
          log(name, 'is a number')
          // We are trying to access an array, but it's not an array, convert it
          let i = Number(name);
          if(!Array.isArray(target)){ // TODO: what does this do for strings?
            log('converting parent to array', name)
            makeProxy(new ProxyArray(), target.__parent__, target.__key__)
            makeProxy(new ProxyObject(), target.__parent__[target.__key__], i)
            return target.__parent__[target.__key__][i]
          }else{
            log('parent is already an array', name)
            makeProxy(new ProxyArray(), target, i);
            return target[i];
          }
        }else{
          log(name, 'is not a number')
          // We are trying to access an object, but it's not, convert it
          if(Array.isArray(target)){
            log('converting parent to object', name)
            makeProxy(new ProxyObject(), target.__parent__, target.__key__)
            makeProxy(new ProxyObject(), target.__parent__[target.__key__], name)
            return target.__parent__[target.__key__][name]
          }else{
            log('parent is already an object', name)
            makeProxy(new ProxyObject(), target, name);
            return target[name]
          }
        }


        /**
         * Some of the values I know of that we are ignoring
         * {} Symbol(util.inspect.custom) true
         * {} 'valueOf' true
         * {} Symbol(Symbol.toStringTag) true
         * {} Symbol(Symbol.toStringTag) true
         */
      },

      set: (target, name, value, receiver)=>{
        log('setting value', target, name, target.__label__, receiver)
        // has the value changed?
        var same = target[name] == value;

        console.log('setter', value, target[name])

        if(traversable(value)){
          log('value is an array. is it already a proxy?', name)
          // if it already has a __proxy__, then it is being set from the getter.
          // we don't need to make it a proxy again.

          // Don't emit the event to the listener if the type has not changed and it's an object or an array
          same = typeof target[name] == typeof value;

          if(!value.__proxy__){
            console.log('it is not a proxy, we need to make it one', name)
            makeProxy(value, target, name);
            if(!same){
              lazy.emit(target.__label__ + '.' + name.toString(), target[name])
            }
            return true;
          }
        }
        // primitive or already a proxy

        target[name] = value;
        if(!same){
          lazy.emit(target.__label__ + '.' + name.toString(), target[name])
        }
        return true;
      }
    });

    return parent[key];
  }

  // This is so we have something to actually proxy.
  const root = {
    store: {}
  };

  function set(value){

    if(!traversable(value)){
      throw new Error('Store must be an array or an object.')
    }

    log('setting proxy')

    makeProxy(value, root, 'store')

    log('done')

    // add event handler back on.
    Object.defineProperty(root.store, 'on', {
      enumerable: false,
      configurable: false,
      writable:  false,
      value: lazy.on
    });
    Object.defineProperty(root.store, 'one', {
      enumerable: false,
      configurable: false,
      writable: false,
      value: lazy.one
    });
    Object.defineProperty(root.store, 'off', {
      enumerable: false,
      configurable: false,
      writable: false,
      value: lazy.off
    });

    Object.defineProperty(root.store, 'set', {
      enumerable: false,
      get: ()=>{
        return set;
      }
    });

    return root.store
  }

  set({})



  if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
    module.exports = root.store;
  }else if(typeof define === 'function' && define.amd) {
    define([], function() {
      return root.store;
    });
  }
  if(typeof window === 'object'){
    Object.defineProperty(window, 'ProxyStore', {
      set:(value)=>{
        console.warn('You are using this the wrong way. Use ProxyStore.set instead of ProxyStore =')
        set(value);
      },
      get: ()=>{
        return root.store;
      }
    })
  }
})()
;
return module.exports;
},
1: function (require, module, exports) {
(function(){

  function LazyEvents(target = {}){

    const events = {};

    Object.defineProperty(target, 'on', {
      get: ()=>{
        return on;
      }
    })
    Object.defineProperty(target, 'one', {
      get: ()=>{
        return one;
      }
    })
    Object.defineProperty(target, 'off', {
      get: ()=>{
        return off;
      }
    })
    Object.defineProperty(target, 'emit', {
      get: ()=>{
        return emit;
      }
    })

    /**
     * Events On.
     * You can listen to '*' and listen to all events
     * @param  {String}   label   Event to listen to
     * @param  {Function} cb      Required. This is the function that will be
     *                            called when the event is triggered.
     * @param  {Boolean}   lazy   When true, it will run even if the emit happens
     *                            after the event is registered. When false, it
     *                            will not trigger until an emit happens after it
     *                            has been registered.
     * @return {undefined}
     */
    function on(label, cb, lazy = true){
      if(typeof cb !== 'function') throw new Error('Callback on events must be a function.')
      if(typeof events[label] == 'undefined'){
        events[label] = []
        events[label].__ran__ = false;
        events[label].__args__ = [];
      }
      events[label].push(cb)
      if(events[label].__ran__ && lazy){
        cb.apply(target, events[label].__args__)
      }

      return target;
    }

    /**
     * Events One.
     * Same as On, but will immediately remove itself once it has resolved once.
     */
    function one(label, cb, lazy = true){
      let _cb = function(){ // do not use double arrow here, it messes up arguments
        let args = Array.from(arguments);
        cb.apply(target, args)
        off(label, _cb);
      }
      on(label, _cb, lazy)
      return target;
    }


    /**
     * Events Off.
     * @param  {String}   label Event to remove
     * @param  {[Function]} cb    Optional. If not provided all events of label
     *                            will be removed. If provided, only events with
     *                            the same callback will be removed.
     * @return {undefined}
     */
    function off(label, cb){
      if(typeof events[label] === 'undefined') return;

      if(typeof cb === 'undefined'){
        delete events[label];
        return;
      }

      for(let i=0; i<events[label].length; i++){
        if(events[label][i] === cb){
          events[label].splice(i, 1);
          i--;
        }
      }
      return target;
    }

    /**
     * Events Emit.
     * @param  {String}   label   Event to emit
     * @param  {Arguments} arguments  All arguments after label will be sent to
     *                                listener.
     * @return {undefined}
     */
    function emit(label){

      if(typeof events[label] == 'undefined'){
        events[label] = []
      }

      // Store incoming values for future listeners
      let args = Array.from(arguments);
      args.shift();
      events[label].__ran__ = true;
      events[label].__args__ = args;

      events[label].forEach((event)=>{
        event.apply(target, events[label].__args__)
      })

      if(typeof events['*'] !== 'undefined'){
        events['*'].forEach((event)=>{
          let args = [].concat(label, events[label].__args__);
          event.apply(target, args);
        })
      }
      return target;
    }

    return target;
  }

  if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
    module.exports = LazyEvents;
  }else if(typeof define === 'function' && define.amd) {
    define([], function() {
      return LazyEvents;
    });
  }else{
    window.LazyEvents = LazyEvents;
  }
})()
;
return module.exports;
}
});
return require(0);
}).call(this, null);
